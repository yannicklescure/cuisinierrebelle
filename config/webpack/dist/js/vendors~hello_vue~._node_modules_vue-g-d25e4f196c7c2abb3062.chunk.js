(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~hello_vue~._node_modules_vue-g"],{

/***/ "./node_modules/vue-google-adsense/dist/VueGoogleAdsense.esm.min.js":
/*!**************************************************************************!*\
  !*** ./node_modules/vue-google-adsense/dist/VueGoogleAdsense.esm.min.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var t="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js",e={rootClass:{type:String,default:"adswrapper"},insClass:{type:String,default:""},insStyle:{type:String,default:"display:block;"},dataAdClient:{type:String,default:""},dataAdSlot:{type:String,default:""},dataAdLayoutKey:{type:String,default:"-fg+5n+6t-e7+r"},dataAdTest:{type:String,default:""},dataAdFormat:{type:String,default:"auto"},isNonPersonalizedAds:{type:String,default:"no"},dataFullWidthResponsive:{type:String,default:"no"}};var a=function(t,e,a,s,d,n,o,i,r,l){"boolean"!=typeof o&&(r=i,i=o,o=!1);var c,p="function"==typeof a?a.options:a;if(t&&t.render&&(p.render=t.render,p.staticRenderFns=t.staticRenderFns,p._compiled=!0,d&&(p.functional=!0)),s&&(p._scopeId=s),n?(c=function(t){(t=t||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(t=__VUE_SSR_CONTEXT__),e&&e.call(this,r(t)),t&&t._registeredComponents&&t._registeredComponents.add(n)},p._ssrRegister=c):e&&(c=o?function(){e.call(this,l(this.$root.$options.shadowRoot))}:function(t){e.call(this,i(t))}),c)if(p.functional){var y=p.render;p.render=function(t,e){return c.call(e),y(t,e)}}else{var u=p.beforeCreate;p.beforeCreate=u?[].concat(u,c):[c]}return a},s=a({render:function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",{class:t.rootClass},[a("script2",{attrs:{type:"text/javascript",async:"true",src:t.ADS_SCRIPT}}),t._v(" "),a("ins",{staticClass:"adsbygoogle",class:t.insClass,style:t.insStyle,attrs:{"data-ad-client":t.dataAdClient,"data-ad-slot":t.dataAdSlot,"data-ad-test":t.dataAdTest,"data-ad-format":t.dataAdFormat,"data-full-width-responsive":"yes"===t.dataFullWidthResponsive}}),t._v(" "),"yes"===t.isNonPersonalizedAds?a("script2",{attrs:{type:"text/javascript"}},[t._v("\n    (adsbygoogle = window.adsbygoogle || []).requestNonPersonalizedAds = 1;\n    (adsbygoogle = window.adsbygoogle || []).push({});\n  ")]):t._e(),t._v(" "),"no"===t.isNonPersonalizedAds?a("script2",{attrs:{type:"text/javascript"}},[t._v("\n    (adsbygoogle = window.adsbygoogle || []).push({});\n  ")]):t._e()],1)},staticRenderFns:[]},void 0,{name:"Adsense",props:e,data:function(){return{ADS_SCRIPT:t}}},void 0,!1,void 0,void 0,void 0),d={install:function(t){t.component("Adsense",s)}},n=function(t,e){var a=Object(t);for(var s in e)Object.prototype.hasOwnProperty.call(e,s)&&(a[s]=e[s]);return a},o=a({render:function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",{class:t.rootClass},[a("script2",{attrs:{type:"text/javascript",async:"true",src:t.ADS_SCRIPT}}),t._v(" "),a("ins",{staticClass:"adsbygoogle",class:t.insClass,style:t.insStyle,attrs:{"data-ad-layout":"in-article","data-ad-format":t.dataAdFormat,"data-ad-client":t.dataAdClient,"data-ad-slot":t.dataAdSlot,"data-ad-test":t.dataAdTest,"data-full-width-responsive":"yes"===t.dataFullWidthResponsive}}),t._v(" "),"yes"===t.isNonPersonalizedAds?a("script2",{attrs:{type:"text/javascript"}},[t._v("\n    (adsbygoogle = window.adsbygoogle || []).requestNonPersonalizedAds = 1;\n    (adsbygoogle = window.adsbygoogle || []).push({});\n  ")]):t._e(),t._v(" "),"no"===t.isNonPersonalizedAds?a("script2",{attrs:{type:"text/javascript"}},[t._v("\n    (adsbygoogle = window.adsbygoogle || []).push({});\n  ")]):t._e()],1)},staticRenderFns:[]},void 0,{name:"InArticleAdsense",props:n(e,{dataAdFormat:{type:String,default:"fluid"}}),data:function(){return{ADS_SCRIPT:t}}},void 0,!1,void 0,void 0,void 0),i={install:function(t){t.component("InArticleAdsense",o)}},r=a({render:function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",{class:t.rootClass},[a("script2",{attrs:{type:"text/javascript",async:"true",src:t.ADS_SCRIPT}}),t._v(" "),a("ins",{staticClass:"adsbygoogle",class:t.insClass,style:t.insStyle,attrs:{"data-ad-format":t.dataAdFormat,"data-ad-layout-key":t.dataAdLayoutKey,"data-ad-client":t.dataAdClient,"data-ad-slot":t.dataAdSlot,"data-ad-test":t.dataAdTest,"data-full-width-responsive":"yes"===t.dataFullWidthResponsive}}),t._v(" "),"yes"===t.isNonPersonalizedAds?a("script2",{attrs:{type:"text/javascript"}},[t._v("\n    (adsbygoogle = window.adsbygoogle || []).requestNonPersonalizedAds = 1;\n    (adsbygoogle = window.adsbygoogle || []).push({});\n  ")]):t._e(),t._v(" "),"no"===t.isNonPersonalizedAds?a("script2",{attrs:{type:"text/javascript"}},[t._v("\n    (adsbygoogle = window.adsbygoogle || []).push({});\n  ")]):t._e()],1)},staticRenderFns:[]},void 0,{name:"InFeedAdsense",props:n(e,{dataAdFormat:{type:String,default:"fluid"}}),data:function(){return{ADS_SCRIPT:t}}},void 0,!1,void 0,void 0,void 0),l={Adsense:d,InArticleAdsense:i,InFeedAdsense:{install:function(t){t.component("InFeedAdsense",r)}},AutoAdsense:{install:function(e,a){var s=a.adClient,d=void 0===s?"":s,n=document.head,o=document.createElement("script");o.type="text/javascript",o.src=t,o.onload=function(){(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:d,enable_page_level_ads:!0})},n.appendChild(o)}}};/* harmony default export */ __webpack_exports__["default"] = (l);
//# sourceMappingURL=VueGoogleAdsense.esm.min.js.map


/***/ }),

/***/ "./node_modules/vue-gtag/dist/vue-gtag.esm.js":
/*!****************************************************!*\
  !*** ./node_modules/vue-gtag/dist/vue-gtag.esm.js ***!
  \****************************************************/
/*! exports provided: default, bootstrap, config, customMap, event, exception, install, linker, optIn, optOut, pageview, purchase, query, refund, screenview, set, setOptions, time */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bootstrap", function() { return bootstrap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "config", function() { return config$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "customMap", function() { return customMap$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "event", function() { return event$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exception", function() { return exception$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "install", function() { return install; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linker", function() { return linker$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "optIn", function() { return optIn$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "optOut", function() { return optOut$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pageview", function() { return pageview$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "purchase", function() { return purchase$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "query", function() { return query$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "refund", function() { return refund$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "screenview", function() { return screenview$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setOptions", function() { return setOptions$1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "time", function() { return time$1; });
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

var noop = function noop() {};
function loadScript(url, preconnectOrigin) {
  return new Promise(function (resolve, reject) {
    var head = document.head || document.getElementsByTagName("head")[0];
    var script = document.createElement("script");
    script.async = true;
    script.src = url;
    script.charset = "utf-8";

    if (preconnectOrigin) {
      var link = document.createElement("link");
      link.href = preconnectOrigin;
      link.rel = "preconnect";
      head.appendChild(link);
    }

    head.appendChild(script);
    script.onload = resolve;
    script.onerror = reject;
  });
}
function warn(msg, err) {
  console.error("[vue-gtag] " + msg);

  if (err && err.stack) {
    console.error(err.stack);
  }
}
function isFn(item) {
  return typeof item === "function";
}
function isObject(item) {
  return item && _typeof(item) === "object" && !Array.isArray(item);
}
function mergeDeep(target) {
  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  if (!sources.length) {
    return target;
  }

  var source = sources.shift();

  if (!isObject(target) || !isObject(source)) {
    return;
  }

  for (var key in source) {
    if (isObject(source[key])) {
      if (!target[key]) {
        Object.assign(target, _defineProperty({}, key, {}));
      }

      mergeDeep(target[key], source[key]);
    } else {
      Object.assign(target, _defineProperty({}, key, source[key]));
    }
  }

  return mergeDeep.apply(void 0, [target].concat(sources));
}

function query () {
  var _window;

  var _getOptions = getOptions(),
      globalObjectName = _getOptions.globalObjectName;

  if (typeof window === "undefined") {
    return;
  }

  (_window = window)[globalObjectName].apply(_window, arguments);
}

var config = (function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var _getOptions = getOptions(),
      config = _getOptions.config,
      includes = _getOptions.includes;

  query.apply(void 0, ["config", config.id].concat(args));

  if (Array.isArray(includes)) {
    includes.forEach(function (domain) {
      query.apply(void 0, ["config", domain.id].concat(args));
    });
  }
});

var event = (function (name) {
  var _params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _getOptions = getOptions(),
      defaultGroupName = _getOptions.defaultGroupName,
      includes = _getOptions.includes;

  var params = _params;

  if (includes && params.send_to == null) {
    params.send_to = includes.map(function (include) {
      return include.id;
    }).concat(defaultGroupName);
  }

  query("event", name, params);
});

var pageview = (function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var arg = args[0];
  var params = {};

  if (typeof arg === "string") {
    params = {
      page_path: arg,
      page_location: window.location.href
    };
  } else {
    params = arg;
  }

  if (params.send_page_view == null) {
    params.send_page_view = true;
  }

  event("page_view", params);
});

var screenview = (function () {
  var _getOptions = getOptions(),
      appName = _getOptions.appName;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var arg = args[0];
  var params = {};

  if (typeof arg === "string") {
    params = {
      screen_name: arg
    };
  } else {
    params = arg;
  }

  if (params.app_name == null) {
    params.app_name = appName;
  }

  if (params.send_page_view == null) {
    params.send_page_view = true;
  }

  event("screen_view", params);
});

var customMap = (function (map) {
  config({
    custom_map: map
  });
});

var time = (function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  event.apply(void 0, ["timing_complete"].concat(args));
});

var exception = (function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  event.apply(void 0, ["exception"].concat(args));
});

var linker = (function (params) {
  config("linker", params);
});

var purchase = (function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  event.apply(void 0, ["purchase"].concat(args));
});

var refund = (function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  event.apply(void 0, ["refund"].concat(args));
});

var set = (function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  query.apply(void 0, ["set"].concat(args));
});

var disable = (function () {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

  var _getOptions = getOptions(),
      includes = _getOptions.includes,
      config = _getOptions.config;

  window["ga-disable-".concat(config.id)] = value;

  if (Array.isArray(includes)) {
    includes.forEach(function (domain) {
      window["ga-disable-".concat(domain.id)] = value;
    });
  }
});

var optIn = (function () {
  disable(false);
});

var optOut = (function () {
  disable(true);
});

var api = {
  query: query,
  config: config,
  event: event,
  pageview: pageview,
  screenview: screenview,
  customMap: customMap,
  time: time,
  exception: exception,
  linker: linker,
  purchase: purchase,
  refund: refund,
  set: set,
  optIn: optIn,
  optOut: optOut
};

var extend = (function () {
  var Vue = getVue();
  Vue.$gtag = Vue.prototype.$gtag = api;
});

var getPageviewTemplate = function getPageviewTemplate() {
  var to = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _getOptions = getOptions(),
      pageTrackerTemplate = _getOptions.pageTrackerTemplate,
      pageTrackerScreenviewEnabled = _getOptions.pageTrackerScreenviewEnabled,
      appName = _getOptions.appName;

  var template;
  var customTemplate = pageTrackerTemplate(to, from);

  if (customTemplate) {
    template = customTemplate;
  } else if (pageTrackerScreenviewEnabled) {
    template = {
      app_name: appName,
      screen_name: to.name
    };
  } else {
    template = {
      page_title: to.name,
      page_path: to.path,
      page_location: window.location.href
    };
  }

  return template;
};
var trackPage = function trackPage() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$to = _ref.to,
      to = _ref$to === void 0 ? {} : _ref$to,
      _ref$from = _ref.from,
      from = _ref$from === void 0 ? {} : _ref$from,
      _ref$params = _ref.params,
      params = _ref$params === void 0 ? {} : _ref$params;

  var _getOptions2 = getOptions(),
      pageTrackerSkipSamePath = _getOptions2.pageTrackerSkipSamePath,
      pageTrackerScreenviewEnabled = _getOptions2.pageTrackerScreenviewEnabled;

  if (pageTrackerSkipSamePath && to.path === from.path) {
    return;
  }

  var newParams = _objectSpread2(_objectSpread2({}, getPageviewTemplate(to, from)), params);

  if (pageTrackerScreenviewEnabled && !newParams.app_name) {
    warn("To use the screenview, add the appName to the plugin options");
    return;
  }

  if (pageTrackerScreenviewEnabled && !newParams.screen_name) {
    warn("To use the screenview, name your routes");
    return;
  }

  if (pageTrackerScreenviewEnabled) {
    screenview(newParams);
    return;
  }

  pageview(newParams);
};
var startRouter = function startRouter(Router) {
  var Vue = getVue();

  var _getOptions3 = getOptions(),
      onBeforeTrack = _getOptions3.onBeforeTrack,
      onAfterTrack = _getOptions3.onAfterTrack,
      config = _getOptions3.config;
  /* istanbul ignore next */


  Router.onReady(function (current) {
    Vue.nextTick().then(function () {
      api.config(config.params);
      trackPage({
        to: current
      });
    });
    Router.afterEach(function (to, from) {
      Vue.nextTick().then(function () {
        onBeforeTrack(to, from);
        trackPage({
          to: to,
          from: from
        });
        onAfterTrack(to, from);
      });
    });
  });
};
var autotrack = function autotrack() {
  var Router = getRouter();

  if (!Router) {
    return;
  }

  startRouter(Router);
};

function _bootstrap () {
  if (typeof document === "undefined" || typeof window === "undefined") {
    return;
  }

  var _getOptions = getOptions(),
      customResourceURL = _getOptions.customResourceURL,
      customPreconnectOrigin = _getOptions.customPreconnectOrigin,
      enabled = _getOptions.enabled,
      globalObjectName = _getOptions.globalObjectName,
      globalDataLayerName = _getOptions.globalDataLayerName,
      config = _getOptions.config,
      pageTrackerEnabled = _getOptions.pageTrackerEnabled,
      onReady = _getOptions.onReady,
      disableScriptLoad = _getOptions.disableScriptLoad;

  var Router = getRouter();
  var isPageTrackerEnabled = Boolean(pageTrackerEnabled && Router);

  if (!enabled) {
    optOut();
  }

  if (window[globalObjectName] == null) {
    window[globalDataLayerName] = window[globalDataLayerName] || [];

    window[globalObjectName] = function () {
      window[globalDataLayerName].push(arguments);
    };
  }

  window[globalObjectName]("js", new Date());

  if (isPageTrackerEnabled) {
    autotrack();
  } else {
    api.config(config.params);
  }

  if (disableScriptLoad) {
    return;
  }

  var resource = "".concat(customResourceURL, "?id=").concat(config.id, "&l=").concat(globalDataLayerName);
  return loadScript(resource, customPreconnectOrigin).then(function () {
    var library = window[globalObjectName];

    if (isFn(onReady)) {
      onReady(library);
    }

    return library;
  }).catch(function (error) {
    warn("Ops! Something happened and gtag.js couldn't be loaded", error);
    return error;
  });
}

var Vue;
var Router;
var options = {
  customResourceURL: "https://www.googletagmanager.com/gtag/js",
  customPreconnectOrigin: "https://www.googletagmanager.com",
  pageTrackerTemplate: noop,
  onBeforeTrack: noop,
  onAfterTrack: noop,
  onReady: noop,
  enabled: true,
  disableScriptLoad: false,
  bootstrap: true,
  globalObjectName: "gtag",
  globalDataLayerName: "dataLayer",
  pageTrackerEnabled: true,
  pageTrackerScreenviewEnabled: false,
  pageTrackerSkipSamePath: true,
  defaultGroupName: "default",
  includes: null,
  appName: null,
  config: {
    id: null,
    params: {
      send_page_view: false
    }
  }
};
var getOptions = function getOptions() {
  return options;
};
var setOptions = function setOptions(_options) {
  return mergeDeep(options, _options);
};
var getVue = function getVue() {
  return Vue;
};
var getRouter = function getRouter() {
  return Router;
};
function install(_Vue) {
  var _options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var _Router = arguments.length > 2 ? arguments[2] : undefined;

  Vue = _Vue;
  Router = _Router;
  setOptions(_options);
  extend();

  if (!options.bootstrap) {
    return;
  }

  _bootstrap();
}

var bootstrap = _bootstrap;
var setOptions$1 = setOptions; // export api for usages outside Vuejs context

var query$1 = api.query;
var config$1 = api.config;
var event$1 = api.event;
var pageview$1 = api.pageview;
var screenview$1 = api.screenview;
var customMap$1 = api.customMap;
var time$1 = api.time;
var exception$1 = api.exception;
var linker$1 = api.linker;
var purchase$1 = api.purchase;
var set$1 = api.set;
var optIn$1 = api.optIn;
var optOut$1 = api.optOut;
var refund$1 = api.refund;

/* harmony default export */ __webpack_exports__["default"] = (install);



/***/ }),

/***/ "./node_modules/vue-infinite-scroll/vue-infinite-scroll.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vue-infinite-scroll/vue-infinite-scroll.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
   true ? module.exports = factory() :
  undefined;
}(this, function () { 'use strict';

  var ctx = '@@InfiniteScroll';

  var throttle = function throttle(fn, delay) {
    var now, lastExec, timer, context, args; //eslint-disable-line

    var execute = function execute() {
      fn.apply(context, args);
      lastExec = now;
    };

    return function () {
      context = this;
      args = arguments;

      now = Date.now();

      if (timer) {
        clearTimeout(timer);
        timer = null;
      }

      if (lastExec) {
        var diff = delay - (now - lastExec);
        if (diff < 0) {
          execute();
        } else {
          timer = setTimeout(function () {
            execute();
          }, diff);
        }
      } else {
        execute();
      }
    };
  };

  var getScrollTop = function getScrollTop(element) {
    if (element === window) {
      return Math.max(window.pageYOffset || 0, document.documentElement.scrollTop);
    }

    return element.scrollTop;
  };

  var getComputedStyle = document.defaultView.getComputedStyle;

  var getScrollEventTarget = function getScrollEventTarget(element) {
    var currentNode = element;
    // bugfix, see http://w3help.org/zh-cn/causes/SD9013 and http://stackoverflow.com/questions/17016740/onscroll-function-is-not-working-for-chrome
    while (currentNode && currentNode.tagName !== 'HTML' && currentNode.tagName !== 'BODY' && currentNode.nodeType === 1) {
      var overflowY = getComputedStyle(currentNode).overflowY;
      if (overflowY === 'scroll' || overflowY === 'auto') {
        return currentNode;
      }
      currentNode = currentNode.parentNode;
    }
    return window;
  };

  var getVisibleHeight = function getVisibleHeight(element) {
    if (element === window) {
      return document.documentElement.clientHeight;
    }

    return element.clientHeight;
  };

  var getElementTop = function getElementTop(element) {
    if (element === window) {
      return getScrollTop(window);
    }
    return element.getBoundingClientRect().top + getScrollTop(window);
  };

  var isAttached = function isAttached(element) {
    var currentNode = element.parentNode;
    while (currentNode) {
      if (currentNode.tagName === 'HTML') {
        return true;
      }
      if (currentNode.nodeType === 11) {
        return false;
      }
      currentNode = currentNode.parentNode;
    }
    return false;
  };

  var doBind = function doBind() {
    if (this.binded) return; // eslint-disable-line
    this.binded = true;

    var directive = this;
    var element = directive.el;

    var throttleDelayExpr = element.getAttribute('infinite-scroll-throttle-delay');
    var throttleDelay = 200;
    if (throttleDelayExpr) {
      throttleDelay = Number(directive.vm[throttleDelayExpr] || throttleDelayExpr);
      if (isNaN(throttleDelay) || throttleDelay < 0) {
        throttleDelay = 200;
      }
    }
    directive.throttleDelay = throttleDelay;

    directive.scrollEventTarget = getScrollEventTarget(element);
    directive.scrollListener = throttle(doCheck.bind(directive), directive.throttleDelay);
    directive.scrollEventTarget.addEventListener('scroll', directive.scrollListener);

    this.vm.$on('hook:beforeDestroy', function () {
      directive.scrollEventTarget.removeEventListener('scroll', directive.scrollListener);
    });

    var disabledExpr = element.getAttribute('infinite-scroll-disabled');
    var disabled = false;

    if (disabledExpr) {
      this.vm.$watch(disabledExpr, function (value) {
        directive.disabled = value;
        if (!value && directive.immediateCheck) {
          doCheck.call(directive);
        }
      });
      disabled = Boolean(directive.vm[disabledExpr]);
    }
    directive.disabled = disabled;

    var distanceExpr = element.getAttribute('infinite-scroll-distance');
    var distance = 0;
    if (distanceExpr) {
      distance = Number(directive.vm[distanceExpr] || distanceExpr);
      if (isNaN(distance)) {
        distance = 0;
      }
    }
    directive.distance = distance;

    var immediateCheckExpr = element.getAttribute('infinite-scroll-immediate-check');
    var immediateCheck = true;
    if (immediateCheckExpr) {
      immediateCheck = Boolean(directive.vm[immediateCheckExpr]);
    }
    directive.immediateCheck = immediateCheck;

    if (immediateCheck) {
      doCheck.call(directive);
    }

    var eventName = element.getAttribute('infinite-scroll-listen-for-event');
    if (eventName) {
      directive.vm.$on(eventName, function () {
        doCheck.call(directive);
      });
    }
  };

  var doCheck = function doCheck(force) {
    var scrollEventTarget = this.scrollEventTarget;
    var element = this.el;
    var distance = this.distance;

    if (force !== true && this.disabled) return; //eslint-disable-line
    var viewportScrollTop = getScrollTop(scrollEventTarget);
    var viewportBottom = viewportScrollTop + getVisibleHeight(scrollEventTarget);

    var shouldTrigger = false;

    if (scrollEventTarget === element) {
      shouldTrigger = scrollEventTarget.scrollHeight - viewportBottom <= distance;
    } else {
      var elementBottom = getElementTop(element) - getElementTop(scrollEventTarget) + element.offsetHeight + viewportScrollTop;

      shouldTrigger = viewportBottom + distance >= elementBottom;
    }

    if (shouldTrigger && this.expression) {
      this.expression();
    }
  };

  var InfiniteScroll = {
    bind: function bind(el, binding, vnode) {
      el[ctx] = {
        el: el,
        vm: vnode.context,
        expression: binding.value
      };
      var args = arguments;
      el[ctx].vm.$on('hook:mounted', function () {
        el[ctx].vm.$nextTick(function () {
          if (isAttached(el)) {
            doBind.call(el[ctx], args);
          }

          el[ctx].bindTryCount = 0;

          var tryBind = function tryBind() {
            if (el[ctx].bindTryCount > 10) return; //eslint-disable-line
            el[ctx].bindTryCount++;
            if (isAttached(el)) {
              doBind.call(el[ctx], args);
            } else {
              setTimeout(tryBind, 50);
            }
          };

          tryBind();
        });
      });
    },
    unbind: function unbind(el) {
      if (el && el[ctx] && el[ctx].scrollEventTarget) el[ctx].scrollEventTarget.removeEventListener('scroll', el[ctx].scrollListener);
    }
  };

  var install = function install(Vue) {
    Vue.directive('InfiniteScroll', InfiniteScroll);
  };

  if (window.Vue) {
    window.infiniteScroll = InfiniteScroll;
    Vue.use(install); // eslint-disable-line
  }

  InfiniteScroll.install = install;

  return InfiniteScroll;

}));

/***/ }),

/***/ "./node_modules/vue-loader/lib/runtime/componentNormalizer.js":
/*!********************************************************************!*\
  !*** ./node_modules/vue-loader/lib/runtime/componentNormalizer.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return normalizeComponent; });
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ "./node_modules/vue-script2/dist/vue-script2.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-script2/dist/vue-script2.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*!
  * vue-script2 v2.1.0
  * (c) 2016-2019 Greg Slepak
  * @license MIT License
  */
(function (global, factory) {
   true ? module.exports = factory() :
  undefined;
}(this, function () { 'use strict';

  var Script2 = {
    installed: false,
    p: Promise.resolve(),
    version: '2.1.0',
    // grunt will overwrite to match package.json
    loaded: {},

    // keys are the scripts that is loading or loaded, values are promises
    install(Vue) {
      if (Script2.installed) return;
      var customAttrs = ['unload']; // from: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script
      // 'async' and 'defer' don't allow document.write according to:
      // http://www.html5rocks.com/en/tutorials/speed/script-loading/
      // we ignore 'defer' and handle 'async' specially.

      var props = customAttrs.concat(['src', 'type', 'async', 'integrity', 'text', 'crossorigin']);
      Vue.component('script2', {
        props: props,

        // <slot> is important, see: http://vuejs.org/guide/components.html#Named-Slots
        // template: '<div style="display:none"><slot></slot></div>',
        // NOTE: Instead of using `template` we can use the `render` function like so:
        render(h) {
          return h('div', {
            style: 'display:none'
          }, this.$slots.default);
        },

        mounted() {
          var parent = this.$el.parentElement;

          if (!this.src) {
            Script2.p = Script2.p.then(() => {
              var s = document.createElement('script');
              var h = this.$el.innerHTML;
              h = h.replace(/&lt;/gi, '<').replace(/&gt;/gi, '>').replace(/&amp;/gi, '&');
              s.type = 'text/javascript';
              s.appendChild(document.createTextNode(h));
              parent.appendChild(s);
              this.$emit('loaded'); // any other proper way to do this or emit error?
            });
          } else {
            var opts = _.omitBy(_.pick(this, props), _.isUndefined);

            opts.parent = parent; // this syntax results in an implicit return

            var load = () => Script2.load(this.src, opts).then(() => this.$emit('loaded'), err => this.$emit('error', err));

            _.isUndefined(this.async) || this.async === 'false' ? Script2.p = Script2.p.then(load) // serialize execution
            : load(); // inject immediately
          } // see: https://vuejs.org/v2/guide/migration.html#ready-replaced


          this.$nextTick(() => {
            // code that assumes this.$el is in-document
            // NOTE: we could've done this.$el.remove(), but IE sucks, see:
            //       https://github.com/taoeffect/vue-script2/pull/17
            this.$el.parentElement.removeChild(this.$el); // remove dummy template <div>
          });
        },

        destroyed() {
          if (this.unload) {
            new Function(this.unload)(); // eslint-disable-line

            delete Script2.loaded[this.src];
          }
        }

      });
      Script2.installed = true;
    },

    load(src) {
      let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        parent: document.head
      };

      if (!Script2.loaded[src]) {
        Script2.loaded[src] = new Promise((resolve, reject) => {
          var s = document.createElement('script'); // omit the special options that Script2 supports

          _.defaults2(s, _.omit(opts, ['unload', 'parent']), {
            type: 'text/javascript'
          }); // according to: http://www.html5rocks.com/en/tutorials/speed/script-loading/
          // async does not like 'document.write' usage, which we & vue.js make
          // heavy use of based on the SPA style. Also, async can result
          // in code getting executed out of order from how it is inlined on the page.


          s.async = false; // therefore set this to false

          s.src = src; // crossorigin in HTML and crossOrigin in the DOM per HTML spec
          // https://html.spec.whatwg.org/multipage/embedded-content.html#dom-img-crossorigin

          if (opts.crossorigin) {
            s.crossOrigin = opts.crossorigin;
          } // inspiration from: https://github.com/eldargab/load-script/blob/master/index.js
          // and: https://github.com/ded/script.js/blob/master/src/script.js#L70-L82


          s.onload = () => resolve(src); // IE should now support onerror and onload. If necessary, take a look
          // at this to add older IE support: http://stackoverflow.com/a/4845802/1781435


          s.onerror = () => reject(new Error(src));

          opts.parent.appendChild(s);
        });
      }

      return Script2.loaded[src];
    }

  };
  var _ = {
    isUndefined(x) {
      return x === undefined;
    },

    pick(o, props) {
      var x = {};
      props.forEach(k => {
        x[k] = o[k];
      });
      return x;
    },

    omit(o, props) {
      var x = {};
      Object.keys(o).forEach(k => {
        if (props.indexOf(k) === -1) x[k] = o[k];
      });
      return x;
    },

    omitBy(o, pred) {
      var x = {};
      Object.keys(o).forEach(k => {
        if (!pred(o[k])) x[k] = o[k];
      });
      return x;
    },

    // custom defaults function suited to our specific purpose
    defaults2(o) {
      for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        sources[_key - 1] = arguments[_key];
      }

      sources.forEach(s => {
        Object.keys(s).forEach(k => {
          if (_.isUndefined(o[k]) || o[k] === '') o[k] = s[k];
        });
      });
    }

  };

  return Script2;

}));


/***/ })

}]);
//# sourceMappingURL=vendors~hello_vue~._node_modules_vue-g-d25e4f196c7c2abb3062.chunk.js.map